#include elf64_syscalls

// Global memory
// TODO: Write allocator
// NOTE: When using stdlib instead of 'mem' intrinsic
// User should use 'mem_start' macro instead.
macro sizeof(int) ( -> (sizeof(int) := int)) 8 end
macro sizeof(ptr) ( -> (sizeof(ptr) := int)) 8 end

macro sizeof(print_uint_buf) ( -> (sizeof(print_uint_buf) := int)) 32 end
macro print_uint_buf ( -> (print_uint_buf := ptr)) mem end
macro mem_start ( -> (mem_start := ptr)) print_uint_buf sizeof(print_uint_buf) add end

macro neqi (int int -> bool)
  eqi not
end

// Array indexing function
macro get_argv ((offset := int) (argv := ptr) -> ptr)
  sizeof(ptr) mul add read4 unsafe_mk_ptr
end

proc mod (int int -> int)
  over over div mul sub
end

// O(n) - Iterate till null byte
proc str_len ((str := ptr) -> (len := int))
  proc str_len_go ((str := ptr) (len := int) -> (str+1 := ptr) (len+1 := int))
    dup read1 0 neqi if
      1 add
      swap
      1 add
      swap
      str_len_go
    end
  end
  0 swap str_len_go pop
end

macro print_str_len ((str := ptr) (len := int) -> )
 1 sys_write pop
end

macro print_str ((str := ptr) -> )
  dup str_len swap print_str_len
end

proc print_bool (bool -> )
  if "true" else "false" end print_str
end

proc print_uint (int -> )
  // Set null byte
  0 print_uint_buf sizeof(print_uint_buf) 1 sub add write1

  // Set buffer pointer counting down
  sizeof(print_uint_buf) 2 sub
  proc print_uint_go ((buf_offset := int) int -> )
    over
    // Get lowest digit
    10 mod '0' add
    // Get pointer to current char in buffer
    swap print_uint_buf over add
    // Go left in the buffer
    rot 1 sub
    // Write char
    rot swap write1
    // Remove last digit
    swap 10 div
    dup 0 eqi if
      // No more digits
      drop
      print_uint_buf swap add 1 add print_str
    else
      swap print_uint_go
    end
  end
  print_uint_go
end
